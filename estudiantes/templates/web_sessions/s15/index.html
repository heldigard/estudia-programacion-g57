<!--
  =====================================================
  S15: Archivos y Fetch API - PLANTILLA HTML
  =====================================================

  Esta p√°gina practica el concepto de PETICIONES HTTP en JavaScript,
  que es equivalente a usar requests en Python.

  CONCEPTOS HTML UTILIZADOS:
  -------------------------
  <section> - Contenedor sem√°ntico para secciones de contenido
  <button> - Bot√≥n clickeable
  onclick="funcion()" - Ejecuta funci√≥n de JavaScript cuando hacen click
  <input> - Campo donde el usuario escribe datos
  <select> - Lista desplegable de opciones
  <option> - Opci√≥n dentro de un select
  value="valor" - Valor por defecto del input

  CONEXI√ìN HTML ‚Üî JAVASCRIPT PARA PETICIONES HTTP:
  ---------------------------------------------------
  1. HTML: <button onclick="obtenerUsuario()">
  2. JavaScript: async function obtenerUsuario() { ... }
  3. La funci√≥n usa fetch() para hacer petici√≥n HTTP

  PETICIONES HTTP:
  ---------------
  GET    - Obtener datos (como requests.get en Python)
  POST   - Crear nuevo recurso (como requests.post)
  PUT    - Actualizar recurso completo (como requests.put)
  DELETE - Eliminar recurso (como requests.delete)

  ATRIBUTOS IMPORTANTES:
  ---------------------
  type="number" - Input solo acepta n√∫meros
  type="text" - Input acepta texto
  placeholder="texto" - Texto de ejemplo en el input
  value="valor" - Valor inicial del input
  min="1" max="10" - Rango permitido (para type="number")
  id="nombre" - Identificador √öNICO para JavaScript encontrar elementos

  ASINCRON√çA EN JAVASCRIPT:
  -------------------------
  Las peticiones fetch son AS√çNCRONAS - toman tiempo y no
  bloquean el navegador mientras esperan respuesta.

  Python (s√≠ncrono por defecto):
    response = requests.get(url)  # Espera aqu√≠
    data = response.json()

  JavaScript (as√≠ncrono):
    async function obtener() {
      const response = await fetch(url);  # Espera sin bloquear
      const data = await response.json();
    }
-->
<!DOCTYPE html>
<html lang="es">
<head>
  <!--
    =====================================================
    HEAD: Metadatos del documento
    =====================================================

    El head contiene informaci√≥n sobre el documento que NO se
    muestra directamente en la p√°gina, como el t√≠tulo y
    conexiones a archivos CSS/JS.
  -->
  <meta charset="UTF-8" />
  <!-- viewport: Hace la p√°gina responsiva (adaptable a m√≥viles) -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>S15 - Fetch API</title>
  <!-- link rel="stylesheet": Conecta el archivo CSS que da estilo a la p√°gina -->
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <!-- main: Contenido principal de la p√°gina -->
  <main class="container">
    <!-- HEADER: Cabecera con t√≠tulo de la p√°gina -->
    <header class="header">
      <h1>üåê Pr√°ctica S15: Fetch API</h1>
      <p class="subtitle">Python + JavaScript: Peticiones HTTP</p>
    </header>

    <!--
      =====================================================
      TARJETA 1: GET - OBTENER UN RECURSO
      =====================================================

      Conceptos clave:
      - GET es el m√©todo HTTP para OBTENER datos
      - fetch() es la funci√≥n nativa de JS para peticiones
      - Equivalente Python: requests.get(url)

      Esta tarjeta demuestra c√≥mo obtener datos desde una API
      usando el m√©todo HTTP GET.
    -->
    <section class="card highlight">
      <h2>üì• GET - Obtener un Recurso</h2>
      <p class="hint">Obtener datos de un servidor (como requests.get en Python)</p>

      <!-- onclick="obtenerUsuario()" ejecuta la funci√≥n en app.js -->
      <button class="btn primary" onclick="obtenerUsuario()">GET /users/1</button>

      <!-- Este div est√° oculto (class="hidden") hasta que JavaScript lo muestre -->
      <div id="resultadoGet" class="result hidden"></div>
    </section>

    <!--
      =====================================================
      TARJETA 2: GET - LISTA DE RECURSOS
      =====================================================

      Conceptos clave:
      - GET con query params (?_limit=5) limita resultados
      - Equivalente Python: requests.get(url, params={"_limit": 5})
      - La API devuelve m√∫ltiples registros en un array
    -->
    <section class="card">
      <h2>üë• GET - Lista de Recursos</h2>
      <p class="hint">Obtener m√∫ltiples elementos</p>
      <button class="btn secondary" onclick="obtenerUsuarios()">GET /users (lista)</button>
      <div id="resultadoGetLista" class="result hidden"></div>
    </section>

    <!--
      =====================================================
      TARJETA 3: GET CON PAR√ÅMETROS (QUERY PARAMS)
      =====================================================

      Conceptos clave:
      - Query Params se agregan a la URL: ?clave=valor
      - Ejemplo: /posts?userId=1 filtra posts del usuario 1
      - Equivalente Python: requests.get(url, params={"userId": 1})

      ESTRUCTURA HTML:
      - input-group: Contenedor para input + label
      - label for="id": Conecta etiqueta con input
      - input id="id": Identificador √∫nico para JavaScript
    -->
    <section class="card">
      <h2>üîç GET con Query Params</h2>
      <p class="hint">Filtrar resultados con par√°metros URL</p>

      <!-- input-group: Contenedor para input y su label -->
      <div class="input-group">
        <!-- for="postsUserId" conecta el label con el input -->
        <label for="postsUserId">ID del Usuario:</label>
        <!-- id="postsUserId" es el identificador que JavaScript usa -->
        <input id="postsUserId" type="number" placeholder="1" value="1" min="1" max="10" />
      </div>

      <button class="btn primary" onclick="obtenerPosts()">GET /posts?userId=X</button>
      <div id="resultadoQueryParams" class="result hidden"></div>
    </section>

    <!--
      =====================================================
      TARJETA 4: POST - CREAR RECURSO
      =====================================================

      Conceptos clave:
      - POST crea NUEVOS recursos en el servidor
      - JSON.stringify() convierte objeto JS a string JSON
      - Equivalente Python: requests.post(url, json=diccionario)

      DIFERENCIA IMPORTANTE:
      Python: requests.post(url, json=nuevo_post)
      JS: fetch(url, {method: "POST", body: JSON.stringify(nuevo_post)})

      JSON.stringify() es necesario porque fetch NO convierte
      autom√°ticamente a JSON como lo hace requests en Python.
    -->
    <section class="card highlight">
      <h2>‚ûï POST - Crear Recurso</h2>
      <p class="hint">Enviar nuevos datos al servidor</p>

      <div class="input-group">
        <label for="postTitulo">T√≠tulo:</label>
        <!-- type="text": Input que acepta texto -->
        <input id="postTitulo" type="text" placeholder="Mi Nuevo Post" value="Mi Nuevo Post" />
      </div>

      <div class="input-group">
        <label for="postCuerpo">Contenido:</label>
        <input id="postCuerpo" type="text" placeholder="Contenido del post" value="Contenido del post" />
      </div>

      <button class="btn success" onclick="crearPost()">POST /posts</button>
      <div id="resultadoPost" class="result hidden"></div>
    </section>

    <!--
      =====================================================
      TARJETA 5: PUT - ACTUALIZAR RECURSO
      =====================================================

      Conceptos clave:
      - PUT actualiza COMPLETAMENTE un recurso existente
      - Reemplaza TODOS los campos del recurso
      - Equivalente Python: requests.put(f"{url}/{id}", json=datos)

      ESTRUCTURA HTML:
      - input-row: Varios inputs en una misma fila (grid layout)
    -->
    <section class="card">
      <h2>‚úèÔ∏è PUT - Actualizar Recurso</h2>
      <p class="hint">Reemplazar completamente un recurso</p>

      <!-- input-row: Dos inputs en una misma fila -->
      <div class="input-row">
        <div class="input-group">
          <label for="putPostId">ID del Post:</label>
          <input id="putPostId" type="number" placeholder="1" value="1" min="1" />
        </div>
        <div class="input-group">
          <label for="putTitulo">Nuevo T√≠tulo:</label>
          <input id="putTitulo" type="text" placeholder="T√≠tulo Actualizado" value="T√≠tulo Actualizado" />
        </div>
      </div>

      <button class="btn secondary" onclick="actualizarPost()">PUT /posts/:id</button>
      <div id="resultadoPut" class="result hidden"></div>
    </section>

    <!--
      =====================================================
      TARJETA 6: DELETE - ELIMINAR RECURSO
      =====================================================

      Conceptos clave:
      - DELETE elimina un recurso del servidor
      - Es una operaci√≥n destructiva (no se puede deshacer)
      - Equivalente Python: requests.delete(f"{url}/{id}")

      style="background: var(--accent-danger)": Sobrescribe el estilo
      para hacer el bot√≥n rojo (indicando operaci√≥n destructiva).
    -->
    <section class="card">
      <h2>üóëÔ∏è DELETE - Eliminar Recurso</h2>
      <p class="hint">Borrar un recurso del servidor</p>

      <div class="input-group">
        <label for="deletePostId">ID del Post a eliminar:</label>
        <input id="deletePostId" type="number" placeholder="1" value="1" min="1" />
      </div>

      <button class="btn primary" style="background: var(--accent-danger);" onclick="eliminarPost()">DELETE /posts/:id</button>
      <div id="resultadoDelete" class="result hidden"></div>
    </section>

    <!--
      =====================================================
      TARJETA 7: HEADERS PERSONALIZADOS
      =====================================================

      Conceptos clave:
      - Headers son metadatos de la petici√≥n HTTP
      - Se usan para autenticaci√≥n, formato de datos, etc.
      - Equivalente Python: requests.get(url, headers={"Autorizaci√≥n": "token"})

      HEADERS COMUNES:
      - Content-Type: Indica el formato de datos (application/json)
      - Authorization: Token de autenticaci√≥n
      - User-Agent: Identifica al cliente
    -->
    <section class="card">
      <h2>üìã Headers Personalizados</h2>
      <p class="hint">Agregar encabezados a la petici√≥n</p>
      <button class="btn option" onclick="consultarConHeaders()">Consultar con Headers</button>
      <div id="resultadoHeaders" class="result hidden"></div>
    </section>

    <!--
      =====================================================
      TARJETA 8: MANEJO DE ERRORES HTTP
      =====================================================

      Conceptos clave:
      - C√≥digos HTTP de error: 404 (Not Found), 500 (Server Error)
      - fetch NO lanza error autom√°ticamente en 4xx
      - Equivalente Python: try/except con response.raise_for_status()

      IMPORTANTE:
      En Python requests, response.raise_for_status() lanza excepci√≥n
      en c√≥digos 4xx/5xx. En fetch, debes verificar response.ok manualmente.
    -->
    <section class="card">
      <h2>‚ö†Ô∏è Manejo de Errores HTTP</h2>
      <p class="hint">C√≥mo manejar respuestas de error (404, 500, etc)</p>

      <!-- botones-grid: Dise√±o de cuadr√≠cula para botones -->
      <div class="botones-grid">
        <button class="btn option" onclick="demoError404()">Error 404</button>
        <button class="btn option" onclick="demoError500()">Error 500</button>
      </div>

      <div id="resultadoErrores" class="result hidden"></div>
    </section>

    <!--
      =====================================================
      TARJETA 9: PROMISE CHAINING VS ASYNC/AWAIT
      =====================================================

      Conceptos clave:
      - .then().catch() es la forma tradicional de manejar promesas
      - async/await hace el c√≥digo "parecer" m√°s s√≠ncrono
      - Equivalente Python: No hay equivalente directo a .then()

      PROMISE CHAINING (.then/.catch):
      fetch(url).then(r => r.json()).then(data => console.log(data))

      ASYNC/AWAIT:
      async function main() {
        const response = await fetch(url);
        const data = await response.json();
      }

      async/await es m√°s similar a Python y m√°s legible.
    -->
    <section class="card highlight">
      <h2>‚õìÔ∏è vs ‚èπÔ∏è Promise Chaining vs Async/Await</h2>
      <p class="hint">Dos formas de manejar peticiones as√≠ncronas</p>

      <div class="botones-grid">
        <button class="btn secondary" onclick="demoThenCatch()">.then().catch()</button>
        <button class="btn primary" onclick="demoAsyncAwait()">async/await</button>
      </div>

      <div id="resultadoComparacion" class="result hidden"></div>
    </section>

    <!--
      =====================================================
      TARJETA 10: TIMEOUT
      =====================================================

      Conceptos clave:
      - Timeout cancela petici√≥n si toma mucho tiempo
      - Equivalente Python: requests.get(url, timeout=5)
      - JS usa AbortController para cancelar fetch

      IMPORTANTE:
      fetch() NO tiene timeout nativo como requests.get(timeout=5).
      Debemos implementarlo manualmente con AbortController.
    -->
    <section class="card">
      <h2>‚è±Ô∏è Timeout</h2>
      <p class="hint">Cancelar petici√≥n si toma demasiado tiempo</p>
      <button class="btn option" onclick="demoTimeout()">Demo Timeout (100ms)</button>
      <div id="resultadoTimeout" class="result hidden"></div>
    </section>

    <!--
      =====================================================
      PANEL DE DEBUG / COMPARACI√ìN
      =====================================================

      Muestra las equivalencias entre Python y JavaScript
      para peticiones HTTP con requests vs fetch.

      PYTHON (requests):
      - import requests necesario
      - response.json() convierte autom√°ticamente
      - response.raise_for_status() lanza excepci√≥n

      JAVASCRIPT (fetch):
      - fetch es nativo (no requiere import)
      - response.json() es as√≠ncrono (requiere await)
      - if (!response.ok) verifica errores manualmente
    -->
    <section class="card debug">
      <h2>üêû HTTP: Python vs JavaScript</h2>
      <p class="hint">Fetch API es nativo en JS (no requiere import)</p>

      <!-- comparison: Dos columnas comparando Python y JavaScript -->
      <div class="comparison">
        <div class="python-code">
          <h4>Python (requests)</h4>
          <pre>import requests

# GET simple
response = requests.get(url)
data = response.json()

# POST con JSON
nuevo_post = {
    "title": "Mi Post",
    "body": "Contenido"
}
response = requests.post(
    url,
    json=nuevo_post
)

# PUT - Actualizar
response = requests.put(
    f"{url}/{id}",
    json=datos_actualizados
)

# DELETE
response = requests.delete(
    f"{url}/{id}"
)

# Con par√°metros
response = requests.get(
    url,
    params={"userId": 1}
)

# Con headers
response = requests.get(
    url,
    headers={
        "Authorization": "Bearer token"
    }
)

# Con timeout
response = requests.get(
    url,
    timeout=5
)

# Manejo de errores
try:
    response = requests.get(url)
    response.raise_for_status()
except requests.HTTPError as e:
    print(f"Error: {e}")</pre>
        </div>
        <div class="js-code">
          <h4>JavaScript (fetch)</h4>
          <pre>// GET simple
const response = await fetch(url);
const data = await response.json();

// POST con JSON
const nuevoPost = {
    title: "Mi Post",
    body: "Contenido"
};
const response = await fetch(url, {
    method: "POST",
    headers: {
        "Content-Type": "application/json"
    },
    body: JSON.stringify(nuevoPost)
});

// PUT - Actualizar
const response = await fetch(
    `${url}/${id}`,
    {
        method: "PUT",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify(datos)
    }
);

// DELETE
const response = await fetch(
    `${url}/${id}`,
    { method: "DELETE" }
);

// Con par√°metros
const response = await fetch(
    `${url}?userId=1`
);

// Con headers
const response = await fetch(url, {
    headers: {
        "Authorization": "Bearer token"
    }
});

// Con timeout (AbortController)
const controller = new AbortController();
setTimeout(() => controller.abort(), 5000);
const response = await fetch(url, {
    signal: controller.signal
});

// Manejo de errores
try {
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
    }
    const data = await response.json();
} catch (error) {
    console.error(error);
}</pre>
        </div>
      </div>

      <!-- warning-box: Advertencias sobre diferencias clave -->
      <div class="warning-box">
        <strong>‚ö†Ô∏è DIFERENCIAS CLAVE:</strong><br>
        1. Python: <code>import requests</code> ‚Üí JS: <code>fetch</code> (built-in, no import)<br>
        2. Python: <code>json=data</code> ‚Üí JS: <code>body: JSON.stringify(data)</code><br>
        3. Python: <code>params=dict</code> ‚Üí JS: Query string en URL<br>
        4. JS <code>fetch</code> NO lanza error en 4xx, verificar <code>response.ok</code>
      </div>
    </section>
  </main>

  <!--
    =====================================================
    CONECTAR JAVASCRIPT
    =====================================================

    S15 NO usa type="module" porque no tiene import/export.
    Simplemente conecta app.js directamente.

    FLUJO COMPLETO:
    ---------------
    1. Usuario hace click en bot√≥n: onclick="obtenerUsuario()"
    2. Browser busca obtenerUsuario en app.js
    3. La funci√≥n usa fetch() para hacer petici√≥n HTTP
    4. Se muestra el resultado en el div correspondiente

    DIFERENCIA CON S12:
    -------------------
    S12 usa type="module" para importar desde utils.js
    S15 NO usa m√≥dulos, solo un archivo app.js simple
  -->
  <script src="app.js"></script>
</body>
</html>
